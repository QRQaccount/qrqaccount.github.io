---
title: 使用C实现协程(一)
date: 2020-08-06 17:42:15
tags:
- C
- 协程
categories:
- 使用C实现协程
---
# 使用C实现协程

文章参考[轮子哥的教程](https://zhuanlan.zhihu.com/p/25993392)以及[风云的博客](https://blog.codingnow.com/2012/07/c_coroutine.html)<br>可以对C/C++协程有个大概了解:[Why c++ coroutine？Why libgo？](https://my.oschina.net/yyzybb/blog/1817226)

## 为什么要使用协程

协程切换的代价更低,速度更快(ns级别)，协程所占用的资源更少。协程的切换完全在用户状态下进行,线程的切换需要在内核空间完成(两次内核态与用户态的切换是主要时间开销)。协程切换所做的事情较少，只涉及基本的CPU上下文切换<br><br>对于切换所做的事,以libco协程切换汇编为例(x86_64部分),附带注释
<!-- more -->
C函数接口:

```c
void coctx_swap( coctx_t *,coctx_t* ) asm("coctx_swap");
```
coctx_t结构体定义:

```c
struct coctx_t {
    void *regs[ 14 ]; 
    size_t ss_size;
    char *ss_sp;
};
```

汇编部分:
```x86asm
	leaq 8(%rsp),%rax   ;%rsp是第一个协程控制块所对应的地址
	leaq 112(%rdi),%rsp ;将第一个参数的值赋值给%rsp寄存器
                        ;即将第一个参数指向的coctx_t结构体中的regs数组作为栈空间使用

    ;将第一个协程控制块需要保存的数据依次压入堆栈
	pushq %rax  
	pushq %rbx
	pushq %rcx
	pushq %rdx
    pushq -8(%rax) ;ret func addr
	pushq %rsi
	pushq %rdi
	pushq %rbp
	pushq %r8
	pushq %r9
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	

	movq %rsi, %rsp ;将第二个参数指向的coctx_t结构体中的regs数组作为一个堆栈使用

    ;将第二个协程控制块中的数据依次取出放入CPU寄存器继续上次的任务
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %r9
	popq %r8
	popq %rbp
	popq %rdi
	popq %rsi
	popq %rax ;ret func addr
	popq %rdx
	popq %rcx
	popq %rbx
	popq %rsp

    ;转移到返回地址处开始执行
	pushq %rax
    xorl %eax, %eax
	ret
```

## 需要实现的功能

需要实现
- 有栈协程
- 使用非共享栈,每个协程创建自己独立的栈
- 实现协程之间类似golang的通道的功能
- 初步使用ucontext系列函数,之后再基于x86_64汇编实现上下文交换函数
> {% post_link 在C程序中使用汇编 %}

尝试实现
- 实现类似与golang的通道的功能
- 基于协程实现一套网络IO库(参考[libmill](https://github.com/sustrik/libmill))
  
## 协程库的API

- coroutine_remuse 唤醒一个指定的被挂起的协程
- coroutine_yeild 挂起指定的协程
- coroutine_create 创建一个coroutine并返回协程控制块的句柄
- coroutine_status 查看指定的协程的状态
- coroutine_runing 返回目前正处于运行态的协程控制块句柄






